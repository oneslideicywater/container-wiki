# 流水线设计

DevOps 是一种研发团队的风格、理念、文化。
<!-- TOC -->

- [流水线心得](#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%BF%83%E5%BE%97)
    - [tips](#tips)
        - [组织架构](#%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84)
        - [考虑artifact多样性](#%E8%80%83%E8%99%91artifact%E5%A4%9A%E6%A0%B7%E6%80%A7)
        - [多环境支持](#%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81)
        - [主要支持图形化操作，且保留直接编辑流水线的入口](#%E4%B8%BB%E8%A6%81%E6%94%AF%E6%8C%81%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%93%8D%E4%BD%9C%E4%B8%94%E4%BF%9D%E7%95%99%E7%9B%B4%E6%8E%A5%E7%BC%96%E8%BE%91%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%85%A5%E5%8F%A3)
    - [性能优化](#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)
        - [Tips](#tips)
            - [使用.dockerignore](#%E4%BD%BF%E7%94%A8dockerignore)
            - [使用缓存](#%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98)
    - [水平扩展](#%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95)
        - [如何保持从节点的构建环境一致？](#%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%BB%8E%E8%8A%82%E7%82%B9%E7%9A%84%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%B8%80%E8%87%B4)
        - [如果保证语言的Runtime一致？](#%E5%A6%82%E6%9E%9C%E4%BF%9D%E8%AF%81%E8%AF%AD%E8%A8%80%E7%9A%84runtime%E4%B8%80%E8%87%B4)
        - [项目划分](#%E9%A1%B9%E7%9B%AE%E5%88%92%E5%88%86)
    - [生态](#%E7%94%9F%E6%80%81)
    - [权衡](#%E6%9D%83%E8%A1%A1)

<!-- /TOC -->

## tips


### 组织架构

 一般作为 PaaS 的一部分，而后者要与内部系统融合。例如，按照中心、部门、工程划分组织层级，并且有相对完整的角色与权限。


### 考虑artifact多样性


不同的技术栈产出的artifact不同。java产出的是jar包，c/c++,go语言产出的是可执行二进制。而如果使用了容器化技术，则产出Docker镜像。


artifact的托管有对应的平台。

artifact| repository
----|-----
docker image | harbor
jar | nexus
二进制可执行 | 对象存储


### 多环境支持

异构芯片支持: amd64/arm64/ppc64 etc.

容器编排环境: kubernetes/openshift

虚机环境: Openstack/Vagrant/已存在的虚拟机


### 主要支持图形化操作，且保留直接编辑流水线的入口

提供易于使用的图形化界面，让使用者直接在界面上编辑流水线。也保留“高级编辑”功能，让使用者在需要极大自由度时可以编辑流水线对象（如 Jenkins 的 jenkinsfile）。


## 性能优化

如果对Gradle比较熟悉的话，都应该了解Task. 一个Task就是构建的一个基本单元。任务(Task)之间有依赖关系，任务的依赖关系组成了DAG图。

性能优化的两个核心目标就是较少资源消耗和缩短构建时长。

- 把可以并行的任务并行,串行任务尽量在同一容器内执行
- 定位运行时间的任务,排查由于网络延迟，I/O延迟，外部系统延迟等引起的长时间阻塞。


### Tips

#### 使用.dockerignore

避免非必要文件传输。

构建镜像时，docker会把Dockerfile所在的目录全部文件发送给Docker Daemon. 因此，如果目录中有大文件的话，机器大量时间进行文件I/O, 严重影响构建效率。


#### 使用缓存

缓存是计算机科学中最重要的概念。构建过程各个环节中，使用网络进行文件传输时尽量使用缓存避免重复下载/上传。

比如: 
- 构建时采用maven仓库要尽量使用内网部署的
- 本地缓存要在不同构建周期间共用。比如`.m2`目录在构建容器中挂载为持久卷(docker volume/kubernetes pvc)。



## 水平扩展

无论什么样的系统当用户量增长后，都面临一个问题--如何增加吞吐量？CI服务器当使用的人数多了，一个服务器明显独木难支。


就拿Jenkins来说，有两个方式来进行水平扩展。手动搭建集群和使用kubernetes插件。

这两种途径都是增加从节点，控制节点负责任务分发。区别在于一个从节点数量是固定的，一个从节点的数量是使用kubernetes来供应从节点，因此是动态伸缩的。

水平扩展考虑以下问题：

### 1. 如何保持从节点的构建环境一致？

如何保持一次完整的构建流程（从git拉取代码到部署）使用任何一个从节点的输出结果是一样的。

要保证这一点，从节点的认证信息，证书，环境变量等要保持一致。从这一点上来讲，使用构建容器这个方法具有天然优势。只要编写编排文件，所有的Pod/Container都是从模板创建出来（因此如果使用jenkins，水平扩展我更推荐kubernetes插件）。


### 2. 如果保证语言的Runtime一致？

不同的项目会使用不同版本的语言Runtime.比如Spring Boot项目编译可能使用不同JDK版本, Vue项目打包使用不同的NodeJs版本。

而构建从节点作为通用构建用途的机器，不可能A项目需要JDK 8, 就往里面添加JDK 8. 改天B项目需要JDK 11, 又加上JDK 11.


这里推荐使用容器作为编译容器的概念，即在构建容器里启动一个编译容器，编译容器的镜像内安装了项目合适的语言Runtime SDK版本(使用到docker容器里启动docker容器的技术，由于非文章主线，不做赘述)。


### 3. 项目划分

需要构建的仓库增多，需要按照产品线/项目进行划分。这是最简单的一点了。

## 生态

- IDE插件支持生成流水线模板配置文件


## 权衡

成本和规划之间的矛盾是永恒的。

流水线涉及的工具链好多，工具链中的每个组件拎出来谈及高可用，稳定性，性能，吞吐量都是一个无穷尽的工作。

要结合实际情况，假如团队只需要一个简单的CI服务器，能够编译，打包，部署。而且负责这方面工作的只有一两个人，那么完全可以写个极简版本，从头到尾都是制式的，模板化。系统也是易用，易部署，易理解，构建单线程的。